
use std::fmt;
use crate::package::{ClassPackage, FunctionPackage, MethodPackage, ValuePackage};
use std::io::Write;
use std::io;

const MKDOCS_COMMENT_HEADER: &'static [u8; 166] = br#"<!---
	This file is autogenerated. Do not edit this file manually. Your changes will be ignored.
	More information: https://github.com/MWSE/MWSE/tree/master/docs
-->
"#;

const LUA_COMMENT_HEADER: &'static [u8; 164] = br#"--[[
	This file is autogenerated. Do not edit this file manually. Your changes will be ignored.
	More information: https://github.com/MWSE/MWSE/tree/master/docs
]]
"#;


pub trait Writable {
	/// Write the mkdocs documentation
	fn write_mkdocs(&self, w: &mut impl Write) -> io::Result<()>;
	/// Write the Emmy documentation
	fn write_lua(&self, w: &mut impl Write) -> io::Result<()>;

}





impl Writable for ClassPackage {
	fn write_mkdocs(&self, w: &mut impl Write) -> io::Result<()> {
		w.write(MKDOCS_COMMENT_HEADER)?;
		let name = self.core.name.as_ref();
		let name_lower = name.to_lowercase();
		let desc = match &self.core.description {
			Some(d) => d.as_ref(),
			None => ""
		};
		writeln!(w, "{name}")?;
		writeln!(w, r#"<div class="search_terms" style="display: none">{name_lower}</div>"#)?;
		writeln!(w, "\n{desc}\n")?;
		writeln!(w, "## Properties")?;

		if let Some(val) = self.values.first() {
			val.write_mkdocs(w)?;
			for val in &self.values[1..] {
				w.write(b"***\n")?;
				val.write_mkdocs(w)?;
			}
		}

		writeln!(w, "## Functions")?;
		if let Some(func) = self.functions.first() {
			func.write_mkdocs(w)?;
			for val in &self.functions[1..] {
				w.write(b"***\n")?;
				val.write_mkdocs(w)?;
			}
		}
		writeln!(w, "## Methods")?;
		if let Some(func) = self.methods.first() {
			func.write_mkdocs(w)?;
			for val in &self.methods[1..] {
				w.write(b"***\n")?;
				val.write_mkdocs(w)?;
			}
		}

		Ok(())
	}
	fn write_lua(&self, w: &mut impl Write) -> io::Result<()> {
		
		Ok(())
	}
}


impl Writable for ValuePackage {
	fn write_mkdocs(&self, w: &mut impl Write) -> io::Result<()> {
		let name = self.core.name.as_ref();
		let name_lower = name.to_lowercase();
		let desc = match self.core.description.as_ref() {
			Some(s) => s.as_ref(),
			None => ""
		};
		let ty = match self.valuetype.as_ref() {
			Some(ty) => ty.as_ref(),
			None => "any"
		};

		write!(w, 
r#"
### `{name}`
<div class="search_terms" style="display: none">{name_lower}</div>

{desc}

**Returns**:

* `result` ({ty})

"#
		)?;
		Ok(())
	}

	fn write_lua(&self, w: &mut impl Write) -> io::Result<()> {
		todo!()
	}
}


impl Writable for FunctionPackage {
	fn write_mkdocs(&self, w: &mut impl Write) -> io::Result<()> {
		let name = self.core.name.as_ref();
		let name_lower = name.to_lowercase();
		let desc = match self.core.description.as_ref() {
			Some(s) => s.as_ref(),
			None => ""
		};
		let parent = match &self.core.parent {
			Some(p) => p.as_ref(),
			_ => todo!("Is this even possible?"),
		};

		let arg_names: String = self.args.iter()
			.map(|a| a.name.as_ref().unwrap().as_ref())
			.collect::<Vec<_>>()
			.join(", ");

		write!(w, 
r#"
### `{name}`
<div class="search_terms" style="display: none">{name_lower}</div>

{desc}

```lua
{parent}.{name}({arg_names})
```

"#
		)?;
		Ok(())
	}

	fn write_lua(&self, w: &mut impl Write) -> io::Result<()> {
		todo!()
	}
}

impl Writable for MethodPackage {
	fn write_mkdocs(&self, w: &mut impl Write) -> io::Result<()> {
		let name = self.core.name.as_ref();
		let name_lower = name.to_lowercase();
		let desc = match self.core.description.as_ref() {
			Some(s) => s.as_ref(),
			None => ""
		};
		let parent = match &self.core.parent {
			Some(p) => p.as_ref(),
			_ => todo!("Is this even possible?"),
		};

		let arg_names: String = self.args.iter()
			.map(|a| a.name.as_ref().unwrap().as_ref())
			.collect::<Vec<_>>()
			.join(", ");

		write!(w, 
r#"
### `{name}`
<div class="search_terms" style="display: none">{name_lower}</div>

{desc}

```lua
{parent}:{name}({arg_names})
```

"#
		)?;
		Ok(())
	}

	fn write_lua(&self, w: &mut impl Write) -> io::Result<()> {
		todo!()
	}
}