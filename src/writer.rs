
use std::collections::HashMap;
use log::debug;

use crate::package::{ClassPkg, FnArg, FunctionPkg, LibPkg, MethodPkg, PkgCore, ValuePkg};
use std::io::Write;
use std::io;

const MKDOCS_COMMENT_HEADER: &'static [u8; 166] = br#"<!---
	This file is autogenerated. Do not edit this file manually. Your changes will be ignored.
	More information: https://github.com/MWSE/MWSE/tree/master/docs
-->
"#;

const LUA_COMMENT_HEADER: &'static [u8; 164] = br#"--[[
	This file is autogenerated. Do not edit this file manually. Your changes will be ignored.
	More information: https://github.com/MWSE/MWSE/tree/master/docs
]]
"#;


// pub trait Writable {
// 	/// Write the mkdocs documentation
// 	fn write_mkdocs(&self, w: &mut impl Write, parent: Option<&PkgCore>) -> io::Result<()>;
// 	// / Write the Emmy documentation
// 	// fn write_lua(&self, w: &mut impl Write, parent: Option<&Pkg<PkgTy>>) -> io::Result<()> {
// 	// 	todo!("Figure out the lua thing")
// 	// }

// }
// impl Writable<!> for ! {
// 	fn write_mkdocs(&self, _w: &mut impl Write, _parent: Option<&!>) -> io::Result<()> {
// 		unreachable!("Something must have gone seriously wrong to get here.")
// 	}
// }



macro_rules! trim_start_matches {
	($val:expr; $($lit:literal),+) => {
		{
			let trimmed = $val $( .trim_start_matches($lit) )+ ;
			if trimmed == $val {
				""
			} else {
				trimmed
			}
		}
		
		
	};
}

macro_rules! trimmed_fn_name {
	($fn_name:expr) => {
		trim_start_matches!($fn_name; 
			"get", "set", "mod",
			"is", "has", "can",
			"open", "close",
			"add", "remove",
			"enable", "disable",
			"apply", "update",
			"find", "show",
			"create", "delete",
			"test", "toggle"
		)
	};
}
macro_rules! trimmed_cls_name {
	($cls_name:expr) => {
		trim_start_matches!($cls_name; "ni", "tes3ui", "tes3", "mwse", "mcm")
	};
}
/// Writes a list of seperated things.
/// Used to write functions and fields
macro_rules! write_separated {
	($parent:ident, $items:expr, $w:expr, $header:literal) => {
		{
			let parent = Some(&$parent.core);
			if $items.len() > 0  {
				write!($w, $header)?;
				for val in $items {
					val.write_mkdocs($w, parent)?;
					write!($w, "\n***\n\n")?;
				}
			}
			Ok(()) as io::Result<()>
		}
	};
}


fn write_search_terms(w: &mut impl Write, name: &str, trimmed_name: &str) -> io::Result<()> {
	let name_lower = name.to_ascii_lowercase();
	let trimmed_name = trimmed_name.to_ascii_lowercase();
	if trimmed_name.len() > 0 {
		writeln!(w, r#"<div class="search_terms" style="display: none">{name_lower}, {trimmed_name}</div>"#)?;
	} else {
		writeln!(w, r#"<div class="search_terms" style="display: none">{name_lower}</div>"#)?;
	}
	Ok(())
}




impl ClassPkg {
	// pub async fn write_mkdocs<'a, W: Unpin + AsyncWriteExt>(&'a self, w: &'a mut W, class_map: Arc<HashMap<&'a str, &'a ClassPkg>>) -> io::Result<()> {
	// 	let mut buf: Vec<u8> = Vec::new();
	// 	buf.extend_from_slice(MKDOCS_COMMENT_HEADER);
	// 	// write!(&mut buf, MKDOCS_COMMENT_HEADER)?;
	// 	// w.write(MKDOCS_COMMENT_HEADER).await?;
	// 	let name = self.core.name.as_ref();
	// 	let desc = match &self.core.description {
	// 		Some(d) => d.as_ref(),
	// 		None => ""
	// 	};

	// 	writeln!(&mut buf, "# {name}")?;
	// 	write_search_terms(&mut buf, name, trimmed_cls_name!(self.core.name.as_str()))?;
		
	// 	writeln!(&mut buf, "\n{desc}\n")?;
	// 	let (values, functions, methods) = self.get_all_values(class_map.as_ref());

	// 	write_separated!(self, values.as_slice(), &mut buf, "## Properties\n\n")?;
	// 	write_separated!(self, functions.as_slice(), &mut buf, "## Functions\n\n")?;
	// 	write_separated!(self, methods.as_slice(), &mut buf, "## Methods\n\n")?;
	// 	// debug!("about to write buffer: {buf:?}");
	// 	w.write(&mut buf).await?;
		

	// 	Ok(())
	// }
	pub fn write_mkdocs<W: Write>(&self, w: &mut W, class_map: &HashMap<&str, &ClassPkg>) -> io::Result<()> {
		w.write(MKDOCS_COMMENT_HEADER)?;
		// w.write(MKDOCS_COMMENT_HEADER).await?;
		let name = self.core.name.as_ref();
		let desc = match &self.core.description {
			Some(d) => d.as_ref(),
			None => ""
		};

		writeln!(w, "# {name}")?;
		write_search_terms(w, name, trimmed_cls_name!(self.core.name.as_str()))?;
		
		writeln!(w, "\n{desc}\n")?;

		// debug!("writing documentation for {self:?}");
		let (values, functions, methods) = self.get_all_values(class_map);
		write_separated!(self, values.as_slice(), w, "## Properties\n\n")?;
		write_separated!(self, functions.as_slice(), w, "## Functions\n\n")?;
		write_separated!(self, methods.as_slice(), w, "## Methods\n\n")?;
		// debug!("about to write buffer: {buf:?}");
		

		Ok(())
	}
}


impl ValuePkg {
	pub fn write_mkdocs(&self, w: &mut impl Write, _: Option<&PkgCore>) -> io::Result<()> {
		let name = self.core.name.as_ref();
		let desc = self.core.description.as_deref().unwrap_or("");
		let ty = self.ty.as_deref().unwrap_or("any");

		writeln!(w, "### `{name}`")?;
		write_search_terms(w, name, "")?;
		write!(w, "\n{desc}\n\n**Returns**:\n\n* `result` ({ty})\n")?;
		Ok(())
	}

}




#[inline]
fn write_param(w: &mut impl Write, param: &FnArg, indentation: usize, default_name: &'static str) -> io::Result<()> {
	let arg_name = param.name.as_deref().unwrap_or(default_name);
	let arg_ty = param.ty.as_deref().unwrap_or("any");
	
	write!(w, "{:indentation$}* `{arg_name}` ({arg_ty})", "")?;

	let arg_desc = param.description.as_deref().unwrap_or("");
	if param.optional {
		write!(w, ": *Optional*. {arg_desc}")?;
	} else if let Some(def) = param.default.as_ref() {
		write!(w, ": *Default*: `{def:?}`. {arg_desc}")?;
	} else if arg_desc.len() > 0 {
		write!(w, ": {arg_desc}")?;
	}
	w.write(b"\n")?;
	if let Some(table_params) = param.table_params.as_ref() {
		for tp in table_params.iter() {
			write_param(w, tp, indentation + 4, default_name)?;
		}
	}

	Ok(())
}


impl FunctionPkg {
	pub fn write_mkdocs(&self, w: &mut impl Write, _parent: Option<&PkgCore>) -> io::Result<()> {
		let name = self.core.name.as_ref();
		let namespace = self.core.namespace();

		let desc = self.core.description.as_deref().unwrap_or("");

		let arg_names: String = self.args.iter()
			.map(|a| a.name.as_deref().unwrap())
			.collect::<Vec<_>>()
			.join(", ");

		let mut ret_names = self.rets.iter()
			.map(|a| a.name.as_deref().unwrap_or("result"))
			.collect::<Vec<_>>()
			.join(", ");
		// add an ` = ` if the ret names are big enough
		if ret_names.len() > 0 {
			ret_names.push_str(" = ");
		}
		writeln!(w, "### `{name}`")?;
		write_search_terms(w, name, trimmed_fn_name!(self.core.name.as_ref()))?;
		write!(w, "\n{desc}\n\n")?;

		write!(w, "```lua\n\
			{ret_names}{namespace}.{name}({arg_names})\n\
			```\n\
		")?;

		if self.args.len() > 0 {
			w.write(b"\n**Parameters**:\n\n")?;

			for param in self.args.iter() {
				write_param(w, param, 0, "unnamed")?;
			}
		}
		if self.rets.len() > 0 {
			w.write(b"\n**Returns**:\n\n")?;

			for param in self.rets.iter() {
				write_param(w, param, 0, "result")?;
			}
		}
		Ok(())
	}

}



impl MethodPkg {
	pub fn write_mkdocs(&self, w: &mut impl Write, parent: Option<&PkgCore>) -> io::Result<()> {
		let name = self.core.name.as_ref();

		let desc = self.core.description.as_deref().unwrap_or("");

		let arg_names: String = self.args.iter()
			.map(|a| a.name.as_ref().unwrap().as_ref())
			.collect::<Vec<_>>()
			.join(", ");

		writeln!(w, "### `{name}`")?;
		write_search_terms(w, name, trimmed_fn_name!(self.core.name.as_ref()))?;

		// This will be equal to the trimmed name of the class prefixed with the word `my`.
		let object_name = {
			let mut trimmed = trimmed_cls_name!(parent.unwrap().name.as_ref()).to_string();
			debug!("trimmed name: {trimmed}");
			debug!("parent name: {}", parent.unwrap().name.as_ref());
			if trimmed.len() > 0 {
				let mut new_prefix = String::with_capacity(3);
				new_prefix.push_str("my");
				// make sure the first letter of the class name is uppercase
				new_prefix.push_str(&trimmed[0..1].to_ascii_uppercase());
				trimmed.replace_range(0..1, &new_prefix);
				trimmed
			} else {
				String::from("myObject")
			}
		};

		write!(w, "\n{desc}\n\
			\n\
			```lua\n\
			{object_name}:{name}({arg_names})\n\
			```\n\
			\n"
		)?;

		if self.args.len() > 0 {
			w.write(b"**Parameters**:\n\n")?;

			for param in self.args.iter() {
				write_param(w, param, 0, "unnamed")?;
			}
		}
		if self.rets.len() > 0 {
			w.write(b"**Returns**:\n\n")?;

			for param in self.rets.iter() {
				write_param(w, param, 0, "result")?;
			}
		}
		Ok(())
	}

}



impl LibPkg {
	pub fn write_mkdocs(&self, w: &mut impl Write) -> io::Result<()> {
		w.write(MKDOCS_COMMENT_HEADER)?;
		// w.write(MKDOCS_COMMENT_HEADER).await?;
		let name = self.core.name.as_ref();
		let desc = match &self.core.description {
			Some(d) => d.as_ref(),
			None => ""
		};

		writeln!(w, "# {name}")?;
		write_search_terms(w, name, trimmed_cls_name!(self.core.name.as_str()))?;
		
		writeln!(w, "\n{desc}\n")?;

		// debug!("writing documentation for {self:?}");
		let (values, functions) = self.get_all_values();
		write_separated!(self, values.as_slice(), w, "## Properties\n\n")?;
		write_separated!(self, functions.as_slice(), w, "## Functions\n\n")?;
		// write_separated!(self, methods.as_slice(), w, "## Methods\n\n")?;
		// debug!("about to write buffer: {buf:?}");
		

		Ok(())
	}
}